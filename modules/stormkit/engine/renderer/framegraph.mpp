module;

#include <stormkit/core/contract_macro.hpp>
#include <stormkit/core/platform_macro.hpp>

export module stormkit.engine:renderer.framegraph;

import std;

import stormkit;

import :renderer.render_surface;

export namespace stormkit::engine {
    using GraphID                    = u64;
    inline constexpr auto INVALID_ID = std::numeric_limits<GraphID>::max();

    struct BufferDescription {
        usize size;
    };

    struct ImageDescription {
        bool               backbuffer = false;
        math::Extent2<u32> extent;
        gpu::ImageType     type;
        gpu::PixelFormat   format;

        u32 layers = 1u;

        std::optional<gpu::ClearValue> clear_value;
    };

    template<class T>
    concept ResourceDescriptionType = meta::Is<T, BufferDescription> || meta::Is<T, ImageDescription>;

    template<ResourceDescriptionType D>
    class STORMKIT_API
    GraphResource {
      public:
        using Description = D;

        GraphResource(std::string name, Description&& description, GraphID creator);
        virtual ~GraphResource();

        GraphResource(const GraphResource&)                    = delete;
        auto operator=(const GraphResource&) -> GraphResource& = delete;

        GraphResource(GraphResource&&) noexcept;
        auto operator=(GraphResource&&) noexcept -> GraphResource&;

        [[nodiscard]]
        auto id() const noexcept -> GraphID;
        [[nodiscard]]
        auto name() const noexcept -> const std::string&;
        [[nodiscard]]
        auto transient() const noexcept -> bool;
        [[nodiscard]]
        auto creator() const noexcept -> GraphID;
        [[nodiscard]]
        auto writers() const noexcept -> const std::vector<GraphID>&;
        [[nodiscard]]
        auto readers() const noexcept -> const std::vector<GraphID>&;
        [[nodiscard]]
        auto ref_count() const noexcept -> usize;
        [[nodiscard]]
        auto description() const noexcept -> const Description&;

      private:
        std::string m_name;
        Description m_description;
        GraphID     m_id;

        GraphID m_creator;

        std::vector<GraphID> m_writers;
        std::vector<GraphID> m_readers;

        usize m_ref_count;

        friend class GraphTaskBuilder;  // TODO rework this
        friend class FrameGraphBuilder; // TODO rework this
    };

    using GraphBuffer = GraphResource<BufferDescription>;
    using GraphImage  = GraphResource<ImageDescription>;

    class FrameGraphBuilder;

    class STORMKIT_API BakedFrameGraph {
      public:
        struct Data {
            struct RasterTask {
                GraphID id;

                gpu::CommandBuffer cmb;

                std::vector<gpu::ClearValue> clear_values = {};
                gpu::RenderPass              renderpass;
                gpu::FrameBuffer             framebuffer;
            };

            struct ComputeTask {
                GraphID id;

                gpu::CommandBuffer cmb;
            };

            using Task = std::variant<RasterTask, ComputeTask>;

            std::vector<Task>             tasks;
            std::vector<gpu::Image>       images      = {};
            std::vector<gpu::ImageView>   image_views = {};
            std::vector<gpu::Buffer>      buffers     = {};
            std::flat_map<GraphID, usize> mapping     = {};

            DeferInit<gpu::CommandBuffer> cmb;
            DeferInit<gpu::Fence>         fence;
            DeferInit<gpu::Semaphore>     semaphore;

            template<typename Self>
            [[nodiscard]]
            auto get_actual_resource(this Self&& self, const GraphBuffer& buffer) noexcept
              -> meta::ForwardLike<Self, gpu::Buffer>;

            template<typename Self>
            [[nodiscard]]
            auto get_actual_resource(this Self&& self, const GraphImage& image) noexcept -> meta::ForwardLike<Self, gpu::Image>;
        };

        BakedFrameGraph(const gpu::Image& backbuffer, Data&& data, BakedFrameGraph* old = nullptr);
        ~BakedFrameGraph();

        BakedFrameGraph(const BakedFrameGraph&)                    = delete;
        auto operator=(const BakedFrameGraph&) -> BakedFrameGraph& = delete;

        BakedFrameGraph(BakedFrameGraph&&) noexcept;
        auto operator=(BakedFrameGraph&&) noexcept -> BakedFrameGraph&;

        [[nodiscard]]
        auto execute(const gpu::Queue& queue) noexcept -> gpu::Expected<Ref<const gpu::Semaphore>>;

        [[nodiscard]]
        auto backbuffer() noexcept -> const gpu::Image&;

      private:
        Ref<const gpu::Image> m_backbuffer;

        Data m_data;

        friend class FrameGraphBuilder;
    };

    class GraphTaskBuilder;

    class STORMKIT_API GraphTask {
      public:
        enum class Type {
            RASTER,
            TRANSFER,
            COMPUTE,
        };

        GraphTask(ioffset data_id, std::string name, Type type = Type::RASTER, bool cull_imune = false);
        virtual ~GraphTask();

        GraphTask(const GraphTask&)                    = delete;
        auto operator=(const GraphTask&) -> GraphTask& = delete;

        GraphTask(GraphTask&&) noexcept;
        auto operator=(GraphTask&&) noexcept -> GraphTask&;

        [[nodiscard]]
        auto id() const noexcept -> GraphID;
        [[nodiscard]]
        auto data_id() const noexcept -> ioffset;
        [[nodiscard]]
        auto name() const noexcept -> const std::string&;
        [[nodiscard]]
        auto type() const noexcept -> Type;
        [[nodiscard]]
        auto cull_imune() const noexcept -> bool;
        [[nodiscard]]
        auto ref_count() const noexcept -> usize;

        [[nodiscard]]
        auto creates() const noexcept -> const std::vector<GraphID>&;
        [[nodiscard]]
        auto writes() const noexcept -> const std::vector<GraphID>&;
        [[nodiscard]]
        auto reads() const noexcept -> const std::vector<GraphID>&;

        auto set_cull_imune(bool imune) noexcept -> void;

        std::function<void(std::byte&, GraphTaskBuilder&)> on_setup;
        std::function<
          void(const std::byte&, OptionalRef<gpu::RenderPass> renderpass, gpu::CommandBuffer& cmb, const BakedFrameGraph::Data&)>
          on_execute;

      private:
        GraphID     m_id;
        ioffset     m_data_id;
        std::string m_name;
        Type        m_type;
        bool        m_cull_imune;
        usize       m_ref_count = 0;

        std::vector<GraphID> m_creates;
        std::vector<GraphID> m_writes;
        std::vector<GraphID> m_reads;

        friend class GraphTaskBuilder;  // TODO rework this
        friend class FrameGraphBuilder; // TODO rework this
    };

    class STORMKIT_API FrameGraphBuilder {
      public:
        template<typename T>
        using SetupCallback = std::function<void(T&, GraphTaskBuilder&)>;
        template<typename T>
        using ExecuteCallback = std::function<
          void(const T&, OptionalRef<gpu::RenderPass>, gpu::CommandBuffer& cmb, const BakedFrameGraph::Data&)>;

        FrameGraphBuilder() noexcept;
        ~FrameGraphBuilder();

        FrameGraphBuilder(const FrameGraphBuilder&)                    = delete;
        auto operator=(const FrameGraphBuilder&) -> FrameGraphBuilder& = delete;

        FrameGraphBuilder(FrameGraphBuilder&&) noexcept;
        auto operator=(FrameGraphBuilder&&) noexcept -> FrameGraphBuilder&;

        template<class TaskData>
        [[nodiscard]]
        auto add_task(std::string               name,
                      SetupCallback<TaskData>   setup,
                      ExecuteCallback<TaskData> execute,
                      GraphTask::Type           type,
                      bool                      cull_imune = false) noexcept -> GraphTask&;

        template<class TaskData>
        [[nodiscard]]
        auto add_raster_task(std::string               name,
                             SetupCallback<TaskData>   setup,
                             ExecuteCallback<TaskData> execute,
                             bool                      cull_imune = false) noexcept -> GraphTask&;

        template<class TaskData>
        [[nodiscard]]
        auto add_transfer_task(std::string               name,
                               SetupCallback<TaskData>   setup,
                               ExecuteCallback<TaskData> execute,
                               bool                      cull_imune = false) noexcept -> GraphTask&;

        template<class TaskData>
        [[nodiscard]]
        auto add_compute_task(std::string               name,
                              SetupCallback<TaskData>   setup,
                              ExecuteCallback<TaskData> execute,
                              bool                      cull_imune = false) noexcept -> GraphTask&;

        template<ResourceDescriptionType Description, typename Resource>
        [[nodiscard]]
        auto set_retained_resource(std::string name, Description&& description, const Resource& res)
          -> GraphResource<Description>&;

        auto set_final_resource(GraphID final) noexcept -> void;

        auto reset() noexcept -> void;
        auto bake() -> void;
        [[nodiscard]]
        auto create_framegraph(const gpu::Device& device, const gpu::CommandPool& command_pool, BakedFrameGraph* old = nullptr)
          -> BakedFrameGraph;
        [[nodiscard]]
        auto allocate_framegraph(const gpu::Device& device, const gpu::CommandPool& command_pool, BakedFrameGraph* old = nullptr)
          -> std::unique_ptr<BakedFrameGraph>;

        [[nodiscard]]
        auto has_task(GraphID id) const noexcept -> bool;
        [[nodiscard]]
        auto has_task(std::string_view name) const noexcept -> bool;

        template<class TaskData, typename Self>
        [[nodiscard]]
        auto get_task(this Self&& self, std::string_view name) noexcept -> decltype(auto);
        template<class TaskData, typename Self>
        [[nodiscard]]
        auto get_task(this Self&& self, GraphID id) noexcept -> decltype(auto);

        template<typename Self>
        [[nodiscard]]
        auto get_task(this Self&& self, std::string_view name) noexcept -> decltype(auto);
        template<typename Self>
        [[nodiscard]]
        auto get_task(this Self&& self, GraphID id) noexcept -> decltype(auto);

        template<class TaskData, typename Self>
        [[nodiscard]]
        auto get_task_data(this Self&& self, std::string_view name) noexcept -> decltype(auto);
        template<class TaskData, typename Self>
        [[nodiscard]]
        auto get_task_data(this Self&& self, GraphID id) noexcept -> decltype(auto);

        [[nodiscard]]
        auto has_resource(GraphID id) const noexcept -> bool;
        [[nodiscard]]
        auto has_resource(std::string_view name) const noexcept -> bool;

        template<class Description, typename Self>
        [[nodiscard]]
        auto get_resource(this Self&& self, std::string_view name) noexcept -> decltype(auto);

        template<class Description, typename Self>
        [[nodiscard]]
        auto get_resource(this Self&& self, GraphID id) noexcept -> decltype(auto);

        template<typename Self>
        [[nodiscard]]
        auto get_resource(this Self&& self, std::string_view name) noexcept -> decltype(auto);
        template<typename Self>
        [[nodiscard]]
        auto get_resource(this Self&& self, GraphID id) noexcept -> decltype(auto);

        [[nodiscard]]
        auto baked() const noexcept -> bool;

      private:
        struct BufferInfo {
            GraphID                 id;
            gpu::Buffer::CreateInfo create_info;
            std::string_view        name;
        };

        struct ImageInfo {
            GraphID                id;
            gpu::Image::CreateInfo create_info;
            gpu::ClearValue        clear_value;
            std::string_view       name;
        };

        struct RenderPassData {
            gpu::RenderPassDescription                  description;
            std::vector<std::vector<gpu::Subpass::Ref>> color_attachment_refs;
            std::vector<std::vector<gpu::Subpass::Ref>> depth_attachment_refs;
            std::vector<std::vector<gpu::Subpass::Ref>> resolve_attachment_refs;
        };

        struct Pass {
            GraphID         id   = INVALID_ID;
            GraphTask::Type type = GraphTask::Type::RASTER;

            RenderPassData   renderpass;
            std::string_view name;

            std::vector<BufferInfo> buffers;
            std::vector<ImageInfo>  images;
        };

        using GraphResourceVariant = std::variant<GraphBuffer, GraphImage>;
        using ResourceVariant      = std::variant<Ref<const gpu::Image>, Ref<const gpu::Buffer>>;

        auto prepare_task(GraphTask& task) noexcept -> void;

        auto cull_unreferenced_resources() noexcept -> void;
        auto build_physical_descriptions() noexcept -> void;
        [[nodiscard]]
        auto build_image_physical_descriptions(const GraphTask& task) noexcept -> std::vector<ImageInfo>;
        [[nodiscard]]
        auto build_buffer_physical_descriptions(const GraphTask& task) noexcept -> std::vector<BufferInfo>;
        [[nodiscard]]
        auto build_renderpass_physical_description(const GraphTask& task, HashMap<GraphID, gpu::ImageLayout>& layouts) noexcept
          -> RenderPassData;
        [[nodiscard]]
        auto allocate_physical_resources(const gpu::CommandPool& command_pool, const gpu::Device& device)
          -> std::pair<Ref<const gpu::Image>, BakedFrameGraph::Data>;

        std::future<void>               m_bake_future;
        std::list<GraphTask>            m_tasks;
        std::list<GraphResourceVariant> m_resources;
        GraphID                         m_final_resource = INVALID_ID;

        std::vector<std::vector<std::byte>> m_datas;

        HashMap<GraphID, ResourceVariant> m_retained_resources;

        std::vector<Pass> m_preprocessed_framegraph;

        bool m_baked = false;

        friend class GraphTaskBuilder;
    };

    class STORMKIT_API GraphTaskBuilder {
      public:
        GraphTaskBuilder(GraphTask& task, FrameGraphBuilder& framegraph) noexcept;
        ~GraphTaskBuilder() noexcept;

        GraphTaskBuilder(const GraphTaskBuilder&) noexcept;
        auto operator=(const GraphTaskBuilder&) noexcept -> GraphTaskBuilder& = delete;

        GraphTaskBuilder(GraphTaskBuilder&&) noexcept;
        auto operator=(GraphTaskBuilder&&) noexcept -> GraphTaskBuilder&;

        template<ResourceDescriptionType Description>
        [[nodiscard]]
        auto create(std::string name, Description&& description) -> GraphResource<Description>&;

        template<ResourceDescriptionType Description>
        [[nodiscard]]
        auto read(GraphResource<Description>& resource) -> GraphResource<Description>&;

        template<ResourceDescriptionType Description>
        [[nodiscard]]
        auto write(GraphResource<Description>& resource) -> GraphResource<Description>&;

        template<ResourceDescriptionType Description>
        [[nodiscard]]
        auto read_write(GraphResource<Description>& resource) -> GraphResource<Description>&;

      private:
        Ref<GraphTask>         m_task;
        Ref<FrameGraphBuilder> m_framegraph;
    };

} // namespace stormkit::engine

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stdr = std::ranges;

namespace stormkit::engine {
    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline GraphResource<D>::GraphResource(std::string name, Description&& description, GraphID creator)
        : m_name { std::move(name) }, m_description { std::forward<Description>(description) }, m_creator { creator } {
        static GraphID s_next_id = 0;

        m_id = s_next_id++;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline GraphResource<D>::~GraphResource()
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline GraphResource<D>::GraphResource(GraphResource&& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::operator=(GraphResource&& other) noexcept -> GraphResource& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::id() const noexcept -> GraphID {
        return m_id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::name() const noexcept -> const std::string& {
        return m_name;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::transient() const noexcept -> bool {
        return m_creator != INVALID_ID;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::creator() const noexcept -> GraphID {
        return m_creator;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::writers() const noexcept -> const std::vector<GraphID>& {
        return m_writers;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::readers() const noexcept -> const std::vector<GraphID>& {
        return m_readers;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::ref_count() const noexcept -> usize {
        return m_ref_count;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType D>
    STORMKIT_FORCE_INLINE
    inline auto GraphResource<D>::description() const noexcept -> const Description& {
        return m_description;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTask::GraphTask(ioffset data_id, std::string name, Type type, bool cull_imune)
        : m_data_id { data_id }, m_name { std::move(name) }, m_type { type }, m_cull_imune { cull_imune } {
        static GraphID s_next_id = 0;

        m_id = s_next_id++;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTask::~GraphTask()
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTask::GraphTask(GraphTask&& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::operator=(GraphTask&& other) noexcept -> GraphTask& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::id() const noexcept -> GraphID {
        return m_id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::data_id() const noexcept -> ioffset {
        return m_data_id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::name() const noexcept -> const std::string& {
        return m_name;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::type() const noexcept -> Type {
        return m_type;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::cull_imune() const noexcept -> bool {
        return m_cull_imune;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::ref_count() const noexcept -> usize {
        return m_ref_count;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::creates() const noexcept -> const std::vector<GraphID>& {
        return m_creates;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::writes() const noexcept -> const std::vector<GraphID>& {
        return m_writes;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::reads() const noexcept -> const std::vector<GraphID>& {
        return m_reads;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTask::set_cull_imune(bool imune) noexcept -> void {
        m_cull_imune = imune;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline BakedFrameGraph::~BakedFrameGraph() {
        if (m_data.fence) auto _ = m_data.fence->wait();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline BakedFrameGraph::BakedFrameGraph(BakedFrameGraph&& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto BakedFrameGraph::operator=(BakedFrameGraph&& other) noexcept -> BakedFrameGraph& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto BakedFrameGraph::backbuffer() noexcept -> const gpu::Image& {
        return *m_backbuffer;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto BakedFrameGraph::Data::get_actual_resource(this Self&& self, const GraphBuffer& buffer) noexcept
      -> meta::ForwardLike<Self, gpu::Buffer> {
        const auto it = self.mapping.find(buffer.id());
        EXPECTS(it != stdr::cend(self.mapping));
        EXPECTS(it->second < stdr::size(self.buffers));

        return std::forward_like<Self>(self.buffers[it->second]);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto BakedFrameGraph::Data::get_actual_resource(this Self&& self, const GraphImage& image) noexcept
      -> meta::ForwardLike<Self, gpu::Image> {
        const auto it = self.mapping.find(image.id());
        EXPECTS(it != stdr::cend(self.mapping));
        EXPECTS(it->second < stdr::size(self.images));

        return std::forward_like<Self>(self.images[it->second]);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline FrameGraphBuilder::FrameGraphBuilder() noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline FrameGraphBuilder::~FrameGraphBuilder()
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline FrameGraphBuilder::FrameGraphBuilder(FrameGraphBuilder&& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::operator=(FrameGraphBuilder&& other) noexcept -> FrameGraphBuilder& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::reset() noexcept -> void {
        m_resources.clear();
        m_tasks.clear();
        m_datas.clear();

        m_baked = false;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    inline auto FrameGraphBuilder::add_task(std::string               name,
                                            SetupCallback<TaskData>   setup,
                                            ExecuteCallback<TaskData> execute,
                                            GraphTask::Type           type,
                                            bool                      cull_imune) noexcept -> GraphTask& {
        expects(not has_task(name), std::format("Task {} already registered !", name));

        auto  id   = std::size(m_datas);
        auto& task = m_tasks.emplace_back(id, std::move(name), type, cull_imune);
        // TODO remove UB
        m_datas.emplace_back(std::vector<std::byte> { sizeof(TaskData), std::byte { 0 } });

        task.on_setup = [setup = std::move(setup)](Byte& data, GraphTaskBuilder& builder) noexcept {
            setup(*std::bit_cast<TaskData*>(&data), builder);
        };
        task.on_execute = [execute = std::move(execute)](const Byte&                  data,
                                                         OptionalRef<gpu::RenderPass> renderpass,
                                                         gpu::CommandBuffer&          cmb,
                                                         const BakedFrameGraph::Data& task_data) noexcept {
            execute(*std::bit_cast<const TaskData*>(&data), std::move(renderpass), cmb, task_data);
        };

        prepare_task(task);

        return task;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::add_raster_task(std::string               name,
                                                   SetupCallback<TaskData>   setup,
                                                   ExecuteCallback<TaskData> execute,
                                                   bool                      cull_imune) noexcept -> GraphTask& {
        return add_task<TaskData>(std::move(name), std::move(setup), std::move(execute), GraphTask::Type::RASTER, cull_imune);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::add_transfer_task(std::string               name,
                                                     SetupCallback<TaskData>   setup,
                                                     ExecuteCallback<TaskData> execute,
                                                     bool                      cull_imune) noexcept -> GraphTask& {
        return add_task<TaskData>(std::move(name), std::move(setup), std::move(execute), GraphTask::Type::TRANSFER, cull_imune);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::add_compute_task(std::string               name,
                                                    SetupCallback<TaskData>   setup,
                                                    ExecuteCallback<TaskData> execute,
                                                    bool                      cull_imune) noexcept -> GraphTask& {
        return add_task<TaskData>(std::move(name), std::move(setup), std::move(execute), GraphTask::Type::COMPUTE, cull_imune);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description, typename Resource>
    inline auto FrameGraphBuilder::set_retained_resource(std::string name, Description&& description, const Resource& res)
      -> GraphResource<Description>& {
        using _GraphResource = GraphResource<Description>;
        auto graph_resource  = _GraphResource { std::move(name), std::forward<Description>(description), INVALID_ID };
        m_retained_resources.emplace(graph_resource.id(), ResourceVariant { as_ref(res) });

        return as<_GraphResource>(m_resources.emplace_back(std::move(graph_resource)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::set_final_resource(GraphID id) noexcept -> void {
        m_final_resource = id;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::has_task(GraphID id) const noexcept -> bool {
        return stdr::any_of(m_tasks, [&](const auto& t) noexcept { return t.id() == id; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::has_task(std::string_view name) const noexcept -> bool {
        return stdr::any_of(m_tasks, [&](const auto& t) noexcept { return t.name() == name; });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task(this Self&& self, std::string_view name) noexcept -> decltype(auto) {
        return as<meta::ForwardLike<Self, GraphTask>>(self.get_task(name));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task(this Self&& self, GraphID id) noexcept -> decltype(auto) {
        return as<meta::ForwardLike<Self, GraphTask>>(self.get_task(id));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task(this Self&& self, std::string_view name) noexcept -> decltype(auto) {
        const auto it = stdr::find_if(self.m_tasks, [&](const auto& t) noexcept { return t.name() == name; });

        ensures(it != stdr::cend(self.m_tasks), std::format("task with name {} not found", name));

        return std::forward_like<Self>(*it);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task(this Self&& self, GraphID id) noexcept -> decltype(auto) {
        auto it = stdr::find_if(self.m_tasks, [&](const auto& t) noexcept { return t.id() == id; });

        ensures(it != stdr::end(self.m_tasks), std::format("task with id {} not found", id));

        return std::forward_like<Self>(*it);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task_data(this Self&& self, std::string_view name) noexcept -> decltype(auto) {
        const auto& task = self.get_task(name);
        const auto  id   = task.data_id();

        return std::forward_like<Self>(*std::bit_cast<meta::ForwardConst<Self, TaskData>*>(stdr::data(self.m_datas[id])));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class TaskData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_task_data(this Self&& self, GraphID graph_id) noexcept -> decltype(auto) {
        const auto& task = self.get_task(graph_id);
        const auto  id   = task.data_id();

        return std::forward_like<Self>(*std::bit_cast<meta::ForwardConst<Self, TaskData>*>(stdr::data(self.m_datas[id])));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::has_resource(GraphID id) const noexcept -> bool {
        return stdr::any_of(m_resources, [&](const auto& t) noexcept {
            return std::visit([&](auto&& t) { return t.id() == id; }, t);
        });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::has_resource(std::string_view name) const noexcept -> bool {
        return stdr::any_of(m_resources, [&](const auto& t) noexcept {
            return std::visit([&](auto&& t) { return t.name() == name; }, t);
        });
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_resource(this Self&& self, std::string_view name) noexcept -> decltype(auto) {
        // return as<meta::ForwardLike<Self, GraphResource<ResourceData>>>(self.get_resource(name));
        return as<GraphResource<ResourceData>>(std::forward_like<Self>(self.get_resource(name)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<class ResourceData, typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_resource(this Self&& self, GraphID id) noexcept -> decltype(auto) {
        return as<GraphResource<ResourceData>>(std::forward_like<Self>(self.get_resource(id)));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_resource(this Self&& self, std::string_view name) noexcept -> decltype(auto) {
        const auto visitor = [name](auto&& value) noexcept { return value.name() == name; };

        auto it = stdr::find_if(self.m_resources, [&](auto&& value) noexcept { return std::visit(visitor, value); });

        ensures(it != stdr::end(self.m_resources), std::format("resource with name {} not found", name));

        return *it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<typename Self>
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::get_resource(this Self&& self, GraphID id) noexcept -> decltype(auto) {
        const auto visitor = [id](auto&& value) noexcept { return value.id() == id; };

        auto it = stdr::find_if(self.m_resources, [&](auto&& value) noexcept { return std::visit(visitor, value); });

        ensures(it != stdr::end(self.m_resources), std::format("resource with id {} not found", id));

        return *it;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto FrameGraphBuilder::baked() const noexcept -> bool {
        return m_baked;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTaskBuilder::GraphTaskBuilder(GraphTask& task, FrameGraphBuilder& framegraph) noexcept
        : m_task { as_ref_mut(task) }, m_framegraph { as_ref_mut(framegraph) } {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTaskBuilder::~GraphTaskBuilder() noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTaskBuilder::GraphTaskBuilder(const GraphTaskBuilder& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline GraphTaskBuilder::GraphTaskBuilder(GraphTaskBuilder&& other) noexcept
      = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    inline auto GraphTaskBuilder::operator=(GraphTaskBuilder&& other) noexcept -> GraphTaskBuilder& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description>
    STORMKIT_FORCE_INLINE
    inline auto GraphTaskBuilder::create(std::string name, Description&& description) -> GraphResource<Description>& {
        auto&  resource = m_framegraph->m_resources.emplace_back(GraphResource<Description> {
          std::move(name),
          std::forward<Description>(description),
          m_task->id() });
        auto&& concrete = as<GraphResource<Description>>(resource);

        m_task->m_creates.emplace_back(concrete.id());
        return concrete;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description>
    STORMKIT_FORCE_INLINE
    inline auto GraphTaskBuilder::read(GraphResource<Description>& resource) -> GraphResource<Description>& {
        resource.m_readers.emplace_back(m_task->id());
        m_task->m_reads.emplace_back(resource.id());

        return resource;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description>
    STORMKIT_FORCE_INLINE
    inline auto GraphTaskBuilder::write(GraphResource<Description>& resource) -> GraphResource<Description>& {
        resource.m_writers.emplace_back(m_task->id());
        m_task->m_writes.emplace_back(resource.id());

        return resource;
    }

    /////////////////////////////////////
    /////////////////////////////////////
    template<ResourceDescriptionType Description>
    STORMKIT_FORCE_INLINE
    inline auto GraphTaskBuilder::read_write(GraphResource<Description>& resource) -> GraphResource<Description>& {
        const auto _ = read(resource);
        const auto _ = write(resource);

        return resource;
    }
} // namespace stormkit::engine
