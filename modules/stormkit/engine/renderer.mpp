// Copyright (C) 2024 Arthur LAURENT <arthur.laurent4@gmail.com>
// This file is subject to the license terms in the LICENSE file
// found in the top-level of this distribution

module;

#include <stormkit/core/platform_macro.hpp>

export module stormkit.engine:renderer;

import std;

import stormkit;

export import :renderer.framegraph;
export import :renderer.render_surface;

export namespace stormkit::engine {
    class STORMKIT_API Renderer final {
        struct PrivateFuncTag {};

      public:
        using UpdateFrameGraphCallbackRef = FunctionRef<void(FrameGraphBuilder&,
                                                             std::atomic_bool&)>;
        constexpr Renderer(PrivateFuncTag) noexcept;
        ~Renderer();

        Renderer(const Renderer&)                    = delete;
        auto operator=(const Renderer&) -> Renderer& = delete;

        Renderer(Renderer&&) noexcept;
        auto operator=(Renderer&&) noexcept -> Renderer&;

        [[nodiscard]]
        static auto create(std::string_view               application_name,
                           OptionalRef<const wsi::Window> window) noexcept
          -> gpu::Expected<Renderer>;
        [[nodiscard]]
        static auto allocate(std::string_view               application_name,
                             OptionalRef<const wsi::Window> window) noexcept
          -> gpu::Expected<Heap<Renderer>>;

        auto update_framegraph(std::mutex&                 mutex,
                               std::atomic_bool&           rebuild_graph,
                               UpdateFrameGraphCallbackRef callback) noexcept;

        auto start_rendering(std::mutex& framegraph_mutex, std::atomic_bool& rebuild_graph) noexcept
          -> void;

        auto instance() const noexcept -> const gpu::Instance&;
        auto device() const noexcept -> const gpu::Device&;
        auto surface() const noexcept -> const RenderSurface&;
        auto raster_queue() const noexcept -> const gpu::Queue&;
        auto main_command_pool() const noexcept -> const gpu::CommandPool&;

      private:
        auto do_init(std::string_view, OptionalRef<const wsi::Window>) noexcept
          -> gpu::Expected<void>;
        auto do_init_instance(std::string_view) noexcept -> gpu::Expected<void>;
        auto do_init_device() noexcept -> gpu::Expected<void>;
        auto do_init_render_surface(OptionalRef<const wsi::Window>) noexcept -> gpu::Expected<void>;

        auto thread_loop(std::mutex&, std::atomic_bool&, std::stop_token) noexcept -> void;
        auto do_render(std::mutex&, std::atomic_bool&, RenderSurface::Frame&&) noexcept
          -> gpu::Expected<RenderSurface::Frame>;

        bool                        m_validation_layers_enabled = false;
        DeferInit<gpu::Instance>    m_instance;
        DeferInit<gpu::Device>      m_device;
        DeferInit<RenderSurface>    m_surface;
        DeferInit<gpu::Queue>       m_raster_queue;
        DeferInit<gpu::CommandPool> m_main_command_pool;

        std::vector<gpu::CommandBuffer> m_command_buffers;

        std::jthread                            m_render_thread;
        FrameGraphBuilder                       m_graph_builder;
        std::vector<DeferInit<BakedFrameGraph>> m_framegraphs;
    };

} // namespace stormkit::engine

////////////////////////////////////////////////////////////////////
///                      IMPLEMENTATION                          ///
////////////////////////////////////////////////////////////////////

namespace stormkit::engine {
    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    constexpr Renderer::Renderer(PrivateFuncTag) noexcept {
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    Renderer::~Renderer() = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    Renderer::Renderer(Renderer&&) noexcept = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::operator=(Renderer&&) noexcept -> Renderer& = default;

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::create(std::string_view               application_name,
                          OptionalRef<const wsi::Window> window) noexcept
      -> gpu::Expected<Renderer> {
        auto renderer = Renderer { PrivateFuncTag {} };
        return renderer.do_init(application_name, std::move(window))
          .transform(core::monadic::consume(renderer));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::allocate(std::string_view               application_name,
                            OptionalRef<const wsi::Window> window) noexcept
      -> gpu::Expected<Heap<Renderer>> {
        auto renderer = core::allocate_unsafe<Renderer>(PrivateFuncTag {});
        return renderer->do_init(application_name, std::move(window))
          .transform(core::monadic::consume(renderer));
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::update_framegraph(std::mutex&                 mutex,
                                     std::atomic_bool&           rebuild_graph,
                                     UpdateFrameGraphCallbackRef callback) noexcept {
        auto _ = std::unique_lock { mutex };
        std::invoke(callback, m_graph_builder, rebuild_graph);
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::start_rendering(std::mutex&       framegraph_mutex,
                                   std::atomic_bool& rebuild_graph) noexcept -> void {
        m_render_thread = std::jthread { bind_front(&Renderer::thread_loop,
                                                    this,
                                                    std::ref(framegraph_mutex),
                                                    std::ref(rebuild_graph)) };
        set_thread_name(m_render_thread, "StormKit:RenderThread");
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::instance() const noexcept -> const gpu::Instance& {
        return m_instance.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::device() const noexcept -> const gpu::Device& {
        return m_device.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::surface() const noexcept -> const RenderSurface& {
        return m_surface.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::raster_queue() const noexcept -> const gpu::Queue& {
        return m_raster_queue.get();
    }

    /////////////////////////////////////
    /////////////////////////////////////
    STORMKIT_FORCE_INLINE
    auto Renderer::main_command_pool() const noexcept -> const gpu::CommandPool& {
        return m_main_command_pool.get();
    }
} // namespace stormkit::engine
